/*
 * soft_timer.c
 *
 *  Created on: Aug 9, 2025
 *      Author: Admin
 */


#include "soft_timer.h"
#include "soft_timer_config.h"
#include "stdint.h"
#include "atomic.h"

static softTimer_t softTimer[SOFT_TIMER_MAX_TIMERS] = {0};


void  soft_timer_update(void)
{

	for (uint16_t i = 0; i < SOFT_TIMER_MAX_TIMERS; i++)
	{
		uint32_t ui32Counter = softTimer[i].ui32TimerCounterInMs;
		if (ui32Counter > 0)
		{
			ui32Counter --;
			if (0 == ui32Counter)
			{
				softTimer[i].bTimerOverFlow = 1;
				//nếu timerPeriodInMS > 0 thì timer là loại periodic
				if (softTimer[i].ui32TimerPeriodInMS > 0) softTimer[i].ui32TimerCounterInMs = softTimer[i].ui32TimerPeriodInMS;
			}
			else softTimer[i].ui32TimerCounterInMs = ui32Counter;

		}
	}
}

void soft_timer_clear_flag(uint32_t ui32SoftTimerID)
{
	if (ui32SoftTimerID < SOFT_TIMER_MAX_TIMERS)
		ATOMIC_WRITE(softTimer[ui32SoftTimerID].ui32TimerOverFlow, 0);
}

void soft_timer_set(uint32_t ui32SoftTimerID, uint32_t ui32Count, bool bIsPeriodic)
{
	if (soft_timer_ID < SOFT_TIMER_MAX_TIMERS)
	{
		ATOMIC_WRITE(softTimer[ui32SoftTimerID].ui32TimerCounterInMs, ui32Count);
		if (bIsPeriodic) ATOMIC_WRITE(softTimer[ui32SoftTimerID].ui32TimerPeriodInMS, ui32Count);
	}
}

void soft_timer_stop(uint32_t ui32SoftTimerID)
{
	if (soft_timer_ID < SOFT_TIMER_MAX_TIMERS)
	{
		ATOMIC_WRITE(softTimer[ui32SoftTimerID].ui32TimerCounterInMs, 0);
		ATOMIC_WRITE(softTimer[ui32SoftTimerID].ui32TimerPeriodInMS, 0);
	}
}
